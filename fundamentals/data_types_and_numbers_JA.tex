<<<<<<< HEAD
% TODO rework structure and hierarchy
\mysection{整数データ型}

整数型とは、数値に変換できる値の型です。これには数値・列挙・ブール値などがあります。

\subsection{ビット}

ビットの明確な使い方はブール値です。: 0は\emph{false}、1は\emph{true}になります.

ブーリアンのセットは\gls{word}にまとめることができます。32ビットのwordには32のブーリアンがあります。
これは\emph{bitmap}または\emph{bitfield}と呼ばれています。

しかし、これには明らかなオーバーヘッドがあります。
ブール変数に\gls{word} (または\emph{int})を使うのは経済的ではありませんが、非常に高速です。

C/C++では0が\emph{false}、0以外の値が\emph{true}になります。
例えば:

\lstinputlisting[style=customc]{fundamentals/data_types_and_numbers_JA_lst1.c}

これはCの文字列を列挙する一般的な方法です:

\lstinputlisting[style=customc]{fundamentals/data_types_and_numbers_JA_lst2.c}

\subsection{ニブル(nibble、別名nybble)}

ハーフバイト、テトラデ\ac{として知られています}。4ビットに相当します。

これらの用語はいずれも現在でも使用されています。

\subsubsection{二進化十進数 (\ac{BCD})}
\label{BCD}

\myindex{Intel 4004}

4ビットニブルは、有名なインテル4004（電卓で使用された）のような4ビットCPUで使用されていました。

4ビットを使って10進数を表現する\emph{binary-coded decimal} (\ac{BCD})という方法があったのは興味深いことです。
10進数0は0b0000、10進数9は0b1001で表され、それ以上の値は使用されません。
10進数1234は0x1234で表されます。もちろんこの方法は経済的ではありません。

それにもかかわらず、この方法には1つの利点があります。それは10進数から\ac{BCD}への変換が容易なことです。
BCD は加算、減算などが可能ですが、追加の修正が必要です。 
x86 CPUにはそのための1Binary-Coded Decimal 443という珍しい命令があります。:
\INS{AAA}/\INS{DAA} (加算後に調整),
\INS{AAS}/\INS{DAS} (減算後に調整),
\INS{AAM} (乗算後に調整),
\INS{AAD} (除算後に調整).

\myindex{x86!\Registers!AF}
CPUが\ac{BCD}をサポートする必要があるので、\emph{half-carry flag} (on 8080/Z80)や
\emph{auxiliary flag} (\TT{AF} on x86)が存在します。
これは下位4ビットを進めた後に生成されるキャリーフラグで、調整命令に使用されます。

変換が容易なことから\InSqBrackets{Peter Abel, \emph{IBM PC assembly language and programming} (1987)}という本が人気になりました。
この本はさておき、著者は\emph{magic numbers}(\myref{magic_numbers})以外に\ac{BCD}ナンバーを見たことがありません。
例えば、誰かの誕生日が0x19791011のようにエンコードされている時、これは確かに\ac{BCD}ナンバーです。

驚くべきことに、著者はSAPソフトウェア上で\ac{BCD}にエンコードされた数字が使われていることに気がつきました。 \url{https://yurichev.com/blog/SAP/}.
価格を含めたいくつかの数字は、データベース上ではBCD形式でエンコードされています。
おそらく、何らかの古いソフトウェア・ハードウェアとの互換性を持たせるために使用されたのではないでしょうか？

x86の\ac{BCD}命令は他の目的、特に文書化されていない方法などでよく使われていました。例えば

\begin{lstlisting}[style=customasmx86]
	cmp al,10
	sbb al,69h
	das
\end{lstlisting}
この曖昧なコードは、0～15の数字を\ac{ASCII}文字 '0'..'9', 'A'..'F'に変換します。

\myparagraph{Z80}
\myindex{Z80}

Z80は8ビットIntel 8080 CPUのクローンであり、そしてスペースの制約のために、それは４ビット\ac{ALU}を持ちます。すなわち
2つの8ビット数にわたる各操作は2段階で進められなければなりません。
この副作用の1つは、\emph{ハーフキャリーフラグ}の簡単で自然な生成です。

\subsection{バイト}

バイトは主に文字の格納に使用されます。 
8ビットバイトは今日のように一般的ではありませんでした。
テレタイプ用のパンチテープには5つか6つの穴があります。これはバイトあたり5または6ビットです。

\myindex{octet}
\myindex{fetchmail}
バイトが8ビットであるという事実を強調するために、バイトは時々\emph{オクテット}と呼ばれます：
少なくとも\emph{fetchmail}はこの用語を使います。

以前は36ビットアーキテクチャで9ビットバイトが存在していました。4 9ビットバイトは1ワードに収まります。
おそらくこの事実のために、C/C++標準は\emph{char}が\emph{少なくとも}8ビットのための余地を持たなければならないと言いますが、
もっと多くのビットが許されます。

例えば、初期のC言語マニュアル\footnote{\url{https://yurichev.com/mirrors/C/bwk-tutor.html}}では、このような例を見つけることができます。

\begin{lstlisting}
char  one byte character (PDP-11, IBM360: 8 bits; H6070: 9 bits)
\end{lstlisting}

\myindex{Honeywell 6070}
H6070までには、おそらくHoneywell 6070を意味し、36ビットの単語が含まれていました。

\subsubsection{標準ASCIIテーブル}

7ビットのASCIIテーブルは標準で128文字しか使用できません。
初期のEメール転送ソフトウェアは7ビットのASCIIコードでしか動作しなかったため、\ac{MIME}規格ではラテン語以外の
書記体系でメッセージをエンコードする必要がありました。 
7ビットASCIIコードは、パリティビットで拡張され、結果として8ビットになりました。

\emph{Data Encryption Standard} (\ac{DES})には56ビットの鍵があります。これは8 7ビットバイトで、
各文字ごとにパリティー・ビットまでのスペースがあります。

\ac{ASCII}テーブル全体を暗記する必要はありませんが、範囲が重要です。
\InSqBrackets{0..0x1F}は制御文字です（印刷不可）。
\InSqBrackets{0x20..0x7E}は印刷可能文字です。
0x80から始まるコードは通常、非ラテン系の書記体系や疑似文字、あるいはその両方に使用されます。

簡単に記憶される重要なコードは次のとおりです。
0（C文字列の終わり、C/C++では\TT{'\textbackslash{}0'}）、
0xAまたは10（\emph{line feed}、C/C++では\TT{'\textbackslash{}n'}）、
0xDまたは13（\emph{carriage return}、C/C++では\TT{'\textbackslash{}r'}）。

0x20（スペース）もよく記憶されています。

\subsubsection{8ビットCPU}

x86は、ARMやMIPSのようなRISC CPUではないので（8ビット8080 CPUの子孫であるため）、
レジスタレベルでバイトを処理することができます。

\subsection{ワイドchar}
\myindex{UTF-16}
\myindex{UCS-2}

これは、バイトを16ビットに拡張することによって、多言語環境をサポートする試みです。
最もよく知られている例は、Windows NTカーネルと\emph{W}サフィックスの付いたwin32関数です。
平文の英語のテキスト文字列の各ラテン文字がゼロバイトでインターリーブされているのはこのためです。
このエンコードはUCS-2またはUTF-16と呼ばれます。

通常、\emph{wchar\_t}は16ビットの\emph{short}データ型の同義語です。

\subsection{符号付き整数と符号なし整数}

符号なしのデータ型は符号付きとして表すことができるため、最初は符号なしデータ型が存在するのはなぜかと主張する人もいます。
はい、ただし値に符号ビットがないと、その範囲は2倍になります。
したがって、符号付きバイトの範囲は-128..127、符号なしバイトの場合は0..255です。
符号なしデータ型を使用するもう1つの利点は自己文書化です。
負の値に代入できない変数を定義します。

\myindex{Java}
符号なしデータ型はJavaには存在しないため、批判されています。
符号付きデータ型に対してブール演算を使用して暗号化アルゴリズムを実装するのは困難です。

0xFFFFFFFF（-1）のような値は、主にエラーコードとしてよく使用されます。

\subsection{ワード(Word)}

\Gls{word}はややあいまいな用語で、通常\ac{GPR}に適合するデータ型を表します。
バイトは文字列には実用的ですが、他の算術計算には実用的ではありません。

したがって、多くの\ac{CPU}には16、32、または64ビット幅の\ac{GPR}があります。 
8080やZ80のような8ビットCPUでも、8ビットレジスタペアで動作するように提供されており、各ペアは16ビット\emph{疑似レジスタ}
（\emph{BC}、\emph{DE}、\emph{HL}など）を形成します。 
Z80はレジスタペアを扱う機能を持っています。これはある意味ではある種の16ビットCPUエミュレーションです。

一般に、CPUが``nビットCPU''として販売されている場合、これは通常、それがnビット\ac{GPR}を持っていることを意味します。

ハードディスクと\ac{RAM}モジュールが\emph{b}キロバイト/メガバイトの代わりに\emph{n}キロワードを
持つものとして販売されていた時代がありました。

例えば、\emph{Apollo Guidance Computer}\footnote{\url{https://en.wikipedia.org/wiki/Apollo_Guidance_Computer}}
には2048ワードの\ac{RAM}があります。
これは16ビットコンピュータだったので、4096バイトの\ac{RAM}がありました。

\emph{TX-0}\footnote{\url{https://en.wikipedia.org/wiki/TX-0}}は64Kの18ビットワードの磁気コアメモリ、
すなわち64キロワードを有していました。

\emph{DECSYSTEM-2060}\footnote{\url{https://en.wikipedia.org/wiki/DECSYSTEM-20}}
は、最大4096キロワードの\emph{ソリッドステートメモリ}
（すなわち、ハードディスク、テープなど）を有することができます。
これは36ビットコンピュータだったので、これは18432キロバイトまたは18メガバイトです。

\myhrule{}

C/C++の\emph{int}はほとんどの場合\gls{word}にマップされます。
（おそらく、よりよい移植性の理由で、AMD64アーキテクチャーを除いて\emph{int}がまだ32ビットのものであるため。）

\emph{int}はPDP-11および古いMS-DOSコンパイラでは16ビットです。 
\emph{int}はVAX上では32ビット、x86上では80386以降で32ビットです。

さらに、C/C++プログラムで変数の型宣言が省略されている場合は、デフォルトで\emph{int}が暗黙的に使用されます。
おそらく、これはBプログラミング言語\footnote{\url{http://yurichev.com/blog/typeless/}}の継承です。

\myhrule{}

\ac{GPR}は通常、変数の最速のコンテナであり、パックされたビットよりも速く、
時にはバイトよりも速いこともあります（GPRからシングルビット/バイトを分離する必要がないため）。 
0..99の範囲でループカウンター用のコンテナとして使用してもです。

\myhrule{}

アセンブリ言語の\Gls{word}は、16ビット8086でもそうだったので、x86ではまだ16ビットです。
\emph{ダブルワード}は32ビット、\emph{クワッドワード}は64ビットです。 
これが、16ビットワードがx86アセンブリで\TT{DW}を使用して宣言され、32ビットワードが\TT{DD}を使用し、64ビットワードが\TT{DW}を使用して宣言されている理由です。

\Gls{word}は、ARM、MIPSなどでは32ビットです。16ビットのデータ型は、\emph{ハーフワード}と呼ばれています。 
したがって、32ビットRISCの\emph{ダブルワード}は64ビットデータ型です。

\emph{GDB}には、16ビットの\emph{ハーフワード}、32ビットの\gls{word}、64ビットの\emph{giant word}という用語があります。

PDP-11およびMS-DOS上の16ビットC/C++環境は、32ビット幅の\emph{long}データ型を持っています。おそらく、
それらは\emph{long word}または\emph{long int}を意味するでしょうか？

32ビットC/C++環境には、64ビット幅の\emph{long long}データ型があります。

単語\emph{word}が曖昧である理由を見ています。

\subsubsection{\emph{int}を使うべきでしょうか？}

曖昧さがバグの原因になる可能性があるため、\emph{int}をまったく使用すべきではないと主張する人もいます。 
たとえば、よく知られている\emph{lzhuf}ライブラリは、ある時点で\emph{int}を使用し、16ビットアーキテクチャではすべてうまく機能します。
しかし、32ビット\emph{int}のアーキテクチャに移植すると、クラッシュする可能性があります：\url{http://yurichev.com/blog/lzhuf/}

それほど曖昧でない型が\emph{stdint.h}ファイルで定義されています：
\emph{uint8\_t}、 \emph{uint16\_t}、 \emph{uint32\_t}、 \emph{uint64\_t}など。

\myindex{Donald E. Knuth}
ドナルドEクヌースのような人たちはこれらのタイプのために9つのより狂ったwordを提案しました\footnote{\url{http://www-cs-faculty.stanford.edu/~uno/news98.html}}：
\emph{byte/wyde/tetrabyte/octabyte}
しかし、これらの名前は、\emph{u}（符号なし）文字を含む明確な用語ほど一般的ではありません。
そして型名の右側に番号を付けます。

\subsubsection{Word志向のコンピュータ}

\gls{word}という言葉のあいまいさにもかかわらず、現代のコンピュータは依然としてワード指向です：\ac{RAM}とキャッシュの
すべてのレベルは依然としてバイト単位ではなくワード単位で構成されています。 
ただし、マーケティングではバイト単位のサイズが使用されます。
% <!-- TODO word length on intel, etc... -->

ワード境界で整列されたアドレスによるRAM/キャッシュへのアクセスは、多くの場合、整列されていない場合よりも安上りです。

高速かつ効率的であると考えられるデータ構造の開発は、
実行するCPU上のワードの長さを常に考慮に入れる必要があります。 
時にはコンパイラはプログラマーのためにこれをしてくれますし、時にはしてくれません。

\subsection{アドレスレジスタ}

ARM、MIPS、PowerPCなど、32ビットまたは64ビットのx86、あるいは90年代のRISCを使っている人にとっては、
アドレスバスの幅が\ac{GPR}や\gls{word}と同じであるのは当然のことです。 
それにもかかわらず、アドレスバスの幅は他のアーキテクチャでは異なる可能性があります。

8ビットZ80は、8ビットレジスタペアまたは専用レジスタ（\emph{IX}、 \emph{IY}）を使用して$2^{16}$バイトをアドレス指定できます。 
\emph{SP} および \emph{PC}レジスタも16ビットのものです。

\myindex{Cray-1}
Cray-1スーパーコンピュータには64ビットのGPRがありますが、24ビットのアドレスレジスタがあるので、
$2^{24}$（16メガワードまたは128メガバイト）をアドレス指定できます。 
RAMは1970年代に非常に高価でした、そしてスーパーコンピューティング環境でさえそれがそれがもっとあるかもしれないと予想することができません。 
それでは、なぜアドレスまたはポインタに64ビットレジスタを割り当てるのでしょうか？

8086/8088 CPUは本当に奇妙なアドレッシングスキームを持っていました：
2つの16ビットレジスタの値は妙な方法で合計されて20ビットアドレスをもたらしました。 
おそらく、これはある種のおもちゃレベルの仮想化でしょうか？（\myref{8086_memory_model}）
8086は複数のプログラムを実行することができます（ただし同時にではありません）。

\myindex{ARM!ARM1}
初期のARM1には興味深いアーティファクトがあります。

\begin{framed}
\begin{quotation}
レジスタファイルに関する別の興味深い点は、PCレジスタに数ビット欠けていることです。 ARM1は26ビットアドレスを使用しているため、上位6ビットは使用されません。 すべての命令は32ビット境界で整列されているため、PCの下位2アドレスビットは常にゼロです。 これらの8ビットは未使用であるだけでなく、チップから完全に省かれています。
\end{quotation}
\end{framed}

( \url{http://www.righto.com/2015/12/reverse-engineering-arm1-ancestor-of.html} )

したがって、最後の2つのビットの1つをPCレジスタに設定して値をプッシュすることは物理的に不可能です。 
PCの上位6ビットに任意のビットを設定することもできません。

x86-64アーキテクチャーには仮想64ビットのポインター/アドレスがありますが、内部的にはアドレスバスの幅は48ビットです
（256TBの\ac{RAM}をアドレス指定するのに十分です）。

\subsection{数値}

数値は何に使われていますか？

CPUレジスタ内のいくつかの数値が変化しているのを見たとき、この数字が何を意味するのかに興味があるかもしれません。
リバースエンジニアにとって、変化する数値のセットから可能なデータタイプを判断することは重要なスキルです。

\subsubsection{ブール値}

数値が0から1に切り替えられたり戻ったりしている場合、この値のデータ型がブール値である可能性が最も高いです。

\subsubsection{ループカウンタ、配列のインデックス}

0、1、2、3\dotsのように0から増加する変数。これはループカウンタや配列インデックスである可能性が高いです。

\subsubsection{符号付き数}

0、1、2、3、および0xFFFFFFFF、0xFFFFFFFE、0xFFFFFFFDのように、非常に小さい数、
場合によっては非常に高い数を保持する変数がある場合、
それは\emph{2の補数}形式（\myref{sec:signednumbers}）の符号付き変数である可能性が高いです。
最後の3つの数字は-1、-2、-3です。

\subsubsection{32ビット数}

非常に大きい数\footnote{\url{https://en.wikipedia.org/wiki/Large_numbers}}があるので、
それらを表すために存在する特別な記法さえあります（クヌースの上向き矢印記法
\footnote{\url{https://en.wikipedia.org/wiki/Knuth\%27s_up-arrow_notation}}）。
これらの数は非常に大きいので、これらは工学、科学および数学にとって実用的ではありません。

ほとんどすべてのエンジニアや科学者はIEEE 754倍精度浮動小数点に満足しています。これは最大値が
$1.8 \cdot 10^{308}$です
（比較として、観測可能な宇宙の原子数は
$4 \cdot 10^{79}$ と $4 \cdot 10^{81}$ の間と推定されます。）

実際には、実用的なコンピューティングの上限ははるかに低いです。 
PDP-11用のUNIX v6のソースコードを入手した場合は
\footnote{\url{http://minnie.tuhs.org/Archive/PDP-11/Distributions/research/Dennis_v6/}}、
どこでも16ビットの\emph{int}が使用されますが、32ビットの\emph{long}型はまったく使用されません。

同じことがMS-DOS時代にもありました。16ビット\emph{int}がほとんどすべて（配列インデックス、ループカウンタ）
に使われていましたが、32ビット\emph{long}はめったに使われませんでした。

x86-64の登場時には、\emph{int}は32ビットサイズの整数のままにすることが決定されました。
おそらく、64ビット\emph{int}の使用はもっとまれであるためです。

私は、0..65535の範囲の16ビット数が、おそらくコンピューティングで最もよく使用される数であると言うでしょう。

Given that, if you see unusually large 32-bit value like 0x87654321, this is a good chance this can be:
それを考えると、あなたが0x87654321のような異常に大きい32ビット値を見るならば、以下のような可能性があるいい機会です。

\begin{itemize}

\item 16ビット数の場合もありますが、符号付きで0xFFFF8000（-32768）から0xFFFFFFFF（-1）までの間です
% TODO: [Example](https://github.com/DennisYurichev/random_notes/blob/master/timedate.md).
\item メモリセルのアドレス（デバッガのメモリマップ機能を使用して確認できます）
\item パックされたバイト（視覚的にチェックすることができます）
\item ビットフラグ
\item （素人の）暗号に関連するもの
\item マジックナンバー(\myref{magic_numbers})
\item IEEE 754浮動小数点数（チェックも可能）

\end{itemize}

64ビット値についてもほぼ同じです。

\myparagraph{\dots では、16ビットの\emph{int}はほとんどすべてのものに十分でしょうか？}

興味深いのは、\InSqBrackets{\MAbrash{} 13章}には、
16ビット変数で十分なケースがたくさんあることがわかったことです。 
それまでの間、Michael Abrashは、80386と80486のCPUには使用可能なレジスタがほとんどないという残念を抱いているので、
2つの16ビット値を1つの32ビットレジスタに入れ、\INS{ROR reg, 16}（80386以降）（\INS{ROL reg, 16}でも動作します）または
\INS{BSWAP}（80486以降）命令を使用して回転させます。

これは、CPUに\INS{EXX}命令を使用して切り替えることができる（その後で元に戻すことができる）
代替の一連のレジスタ（アポストロフィを付けたもの）をZ80に思い出させるものです。

\subsubsection{バッファのサイズ}

プログラマがバッファのサイズを宣言する必要があるときは、通常$2^x$形式の値が使われます（512 バイト、1024など）。
$2^x$形式の値は10進数、16進数、および2進数で簡単に認識できます（\myref{2n_numbers_table}）。

しかし言うまでもなく、プログラマーはまだ彼らの十進文化を持つ人間です。 
そしてどういうわけか、 \ac{DBMS}の領域ではでは、テキストデータベースフィールドのサイズは、100、200のように、$10^x$の数字が選択されます。 
\q{100で十分、ちょっと待って、200がいいでしょう}と考えるだけかもしれません。
そしてもちろん、それは正しいです。 

\oracle の\emph{VARCHAR2}データ型の最大幅は 4096文字ではなく4000文字です。

これには何の問題もありません、これはちょうど$10^x$のような数字に出会うことができる場所です。

\subsubsection{アドレス}

現在デバッグしているプロセスのおおよそのメモリマップを覚えておくことは常に良い考えです。
たとえば、多くのwin32実行可能ファイルは0x00401000から始まっているので、0x00451230のようなアドレスはおそらく
実行可能セクション内にあります。\TT{EIP}レジスタにこれらのアドレスが表示されます。 

スタックは通常下のどこかにあります。 % TODO

多くのデバッガはデバッグ対象のメモリマップを表示することができます、例えば：\myref{olly_memory_map_example}

32ビットアーキテクチャーでは4ステップ、64ビットアーキテクチャーでは8ステップで値が増加している場合、
これはおそらく配列のいくつかの要素のアドレスのスライディングです。

win32が0x10000以下のアドレスを使用していないことを知っておくことは重要です。この定数よりも小さい値を見たら、
これをアドレスにすることはできません（\url{https://msdn.microsoft.com/en-us/library/ms810627.aspx}も参照）。

とにかく、多くのデバッガはレジスタの値が何かへのアドレスになることができるかどうかをあなたに見せることができます。 
OllyDbgは値がアドレスの場合は、ASCII文字列も表示できます。

\subsubsection{ビットフィールド}

0xABCD1234 $\rightarrow$ 0xABCD1434のように、1ビット以上が反転している値が表示される場合、
これはおそらくビットフィールド（またはビットマップ）です。

\subsubsection{パックされたバイト}

\myindex{\CStandardLibrary!strcmp()}
\myindex{\CStandardLibrary!memcmp()}
\emph{strcmp()} または \emph{memcmp()}がバッファをコピーするとき、同時に4（または8）バイトをロード/格納します。
\q{4321}が含まれていて、別の場所にコピーされたら、
一時、0x31323334の値があるレジスタに表示されます。
これは32ビット値に4バイトにパックされています。
