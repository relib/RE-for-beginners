\mysection{減算および加算としてのANDおよびOR}
\label{AND_OR_as_SUB_ADD}

\subsection{ZX Spectrum ROMのテキスト文字列}
\myindex{ZX Spectrum}

かつてZX Spectrum \ac{ROM}の内部を調べた人たちは、おそらく各テキスト文字列の最後のシンボルが一見欠けていることに
気づいたでしょう。

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{fundamentals/zx_spectrum_ROM.png}
\caption{ZX Spectrum ROMの一部}
\end{figure}

実際には存在します。

これは逆アセンブルされたZX Spectrum 128K ROMの抜粋です。

\lstinputlisting{fundamentals/ZX_Spectrum_ROM.lst}
( \url{http://www.matthew-wilson.net/spectrum/rom/128_ROM0.html} )

最後の文字には最上位ビットが設定されており、これが文字列の終わりを示します。
おそらく、それはいくつかのスペースを節約するために行われたのでしょうか。
古い8ビットコンピュータは非常に制約の厳しい環境にあります。

すべてのメッセージの文字は常に標準の7ビット\ac{ASCII}テーブルなので、
7番目のビットが文字に使用されることは決してありません。

そのような文字列を印刷するには、\ac{MSB}をチェックする必要があります。設定されていたら、我々はそれをクリアして、それから文字を印刷して、
次に止めなければなりません。
これがCの例です。

\begin{lstlisting}[style=customc]
unsigned char hw[]=
{
	'H',
	'e',
	'l',
	'l',
	'o'|0x80
};

void print_string()
{
	for (int i=0; ;i++)
	{
		if (hw[i]&0x80) // MSBをチェック
		{
			// MSBをクリア
			// (言い換えると、下位7ビットを残して、すべてクリア)
			printf ("%c", hw[i] & 0x7F);
			// 停止
			break;
		};
		printf ("%c", hw[i]);
	};
};
\end{lstlisting}

7番目のビットは（バイト単位で）最も重要なビットなので、今興味深いところです。それをチェックし、設定し、
論理演算の代わりに算術演算を使用して削除することができます。

Cの例を書き直すことができます。

\begin{lstlisting}[style=customc]
unsigned char hw[]=
{
	'H',
	'e',
	'l',
	'l',
	'o'+0x80
};

void print()
{
	for (int i=0; ;i++)
	{
		// hw[] は'unsigned char'型を持っていなければならない
		if (hw[i] >= 0x80) // MSBをチェック
		{
			printf ("%c", hw[i]-0x80); // clear MSB
			// 停止
			break;
		};
		printf ("%c", hw[i]);
	};
};
\end{lstlisting}

デフォルトでは、\emph{char}はC/C++では符号付き型なので、0x80のような変数（符号付きとして扱われる場合は負の値（$-128$））
と比較するには、
テキストメッセージ内の各文字を符号なしとして扱う必要があります。

7番目のビットが設定されている場合、数値は常に0x80以上になります。
7番目のビットがクリアされていると、数値は常に0x80より小さくなります。

それよりもさらに、7番目のビットが設定されている場合は、0x80を引くことでクリアできます。
事前に設定されていない場合は、減算すると他のビットが破壊されます。

同様に、7番目のビットがクリアされている場合は、0x80を追加して設定できます。
しかし、それが事前に設定されている場合、加算操作は他のいくつかのビットを破壊します。

実際、これはどのビットにも有効です。
4番目のビットがクリアされている場合は、0x10: 0x100+0x10 = 0x110を追加するだけで設定できます。
4番目のビットが設定されている場合は、0x10: 0x1234-0x10 = 0x1224を減算することによってそれをクリアすることができます。

加算/減算中にキャリーが発生しないため、うまくいきます。
ただし、加算前にビットがすでに設定されている場合、または減算前にビットが設定されていない場合はキャリーが発生します。

同様に、2つの条件が満たされる場合、加算/減算はOR/AND演算を使用して置き換えることができます。
1）$2^n$の形式の数で加算/減算したい。
2）ソース値のこのビットはクリア/設定されている。

たとえば、0x20を加算することは、このビットがクリアされる前の条件では、0x20との論理和の値と同じです。
0x1204|0x20 = 0x1204+0x20 = 0x1224.

0x20の減算は、 ~0x20 (0x....FFDF)とのAND値と同じですが、このビットが前に設定されている場合は、
0x1234\&(\~{}0x20) = 0x1234\&0xFFDF = 0x1234-0x20 = 0x1214 です。

繰り返しますが、$2^n$の数を追加してもこのビットが以前に設定されていないとキャリーが発生しなかったためです。

ブール代数のこの性質は重要であり、それを理解し、心に留めておく価値があります。

この本のもう一つの例：\myref{toupper_bit}
