\newcommand{\ARMELF}{\InSqBrackets{\emph{ELF for the ARM 64-bit Architecture (AArch64)}, (2013)}\footnote{\AlsoAvailableAs \url{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056b/IHI0056B_aaelf64.pdf}}}

\subsection{Релоки в ARM64}
\label{ARM64_relocs}

Как известно, в ARM64 инструкции 4-байтные, так что записать длинное число в регистр одной инструкцией нельзя.

Тем не менее, файл может быть загружен по произвольному адресу в памяти, для этого релоки и нужны.

Больше о них (в связи с Win32 PE): \myref{subsec:relocs}.

\myindex{ARM!\Instructions!ADRP/ADD pair}
В ARM64 принят следующий метод: адрес формируется при помощи пары инструкций: \TT{ADRP} и \ADD.

Первая загружает в регистр адрес 4KiB-страницы, а вторая прибавляет остаток.

Скомпилируем пример из \q{\HelloWorldSectionName} 
(\lstref{hw_c}) в GCC (Linaro) 4.9 под win32:

\lstinputlisting[caption=GCC (Linaro) 4.9 и objdump объектного файла,style=customasmARM]{patterns/ARM/relocs1.lst}

Итак, в этом объектом файле три релока.

\begin{itemize}
\item 
Самый первый берет адрес страницы, отсекает младшие 12 бит и записывает оставшиеся старшие 21
в битовые поля инструкции \TT{ADRP}. Это потому что младшие 12 бит кодировать не нужно,
и в ADRP выделено место только для 21 бит.

\item Второй ---- 12 бит адреса, относительного от начала страницы, в поля инструкции \ADD.

\item Последний, 26-битный, накладывается на инструкцию по адресу \TT{0x10}, где переход на функцию \printf.

Все адреса инструкций в ARM64 (да и в ARM в режиме ARM) имеют нули в двух младших битах
(потому что все инструкции имеют размер в 4 байта),
так что нужно кодировать только старшие 26 бит из 28-битного адресного пространства ($\pm 128$MB).

\end{itemize}

В слинкованном исполняемом файле релоков в этих местах нет: потому что там уже точно известно, 
где будет находиться строка \q{Hello!}, и в какой странице, а также известен адрес функции \puts.

И поэтому там, в инструкциях \TT{ADRP}, \ADD и \TT{BL}, уже проставлены нужные значения 
(их проставил линкер во время компоновки):

\lstinputlisting[caption=objdump исполняемого файла,style=customasmARM]{patterns/ARM/relocs2.lst}

\myindex{ARM!\Instructions!BL}

В качестве примера, попробуем дизассемблировать инструкцию BL вручную.\\
\TT{0x97ffffa0} это $0b10010111111111111111111110100000$.
В соответствии с \InSqBrackets{\ARMSixFourRef C5.6.26}, \emph{imm26} это последние 26 бит:\\
$imm26 = 0b11111111111111111110100000$.
Это \TT{0x3FFFFA0}, но \ac{MSB} это 1, 
так что число отрицательное, мы можем вручную его конвертировать в удобный для нас вид.
По правилам изменения знака (\myref{sec:signednumbers:negation}), просто инвертируем все биты: (\TT{0b1011111=0x5F}) и прибавляем 1 (\TT{0x5F+1=0x60}).
Так что число в знаковом виде: \TT{-0x60}.
Умножим \TT{-0x60} на 4 (потому что адрес записанный в опкоде разделен на 4): это \TT{-0x180}.
Теперь вычисляем адрес назначения: \TT{0x4005a0} + (\TT{-0x180}) = \TT{0x400420} 
(пожалуйста заметьте: мы берем адрес инструкции BL, а не текущее значение \ac{PC}, которое может быть другим!).
Так что адрес в итоге \TT{0x400420}.\\
\\
Больше о релоках связанных с ARM64: \ARMELF.
